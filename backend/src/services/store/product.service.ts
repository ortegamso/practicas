import Product, { IProduct, ProductCategory } from '../../models/mongodb/product.model';
import { AppError, HttpCode } from '../../utils/appError';
import mongoose from 'mongoose';

// DTO for creating a product
export interface ProductCreateDto {
  name: string;
  description: string;
  price: number;
  currency?: string;
  category: ProductCategory | string;
  tags?: string[];
  stock?: number;
  images?: string[];
  isActive?: boolean;
  // slug is auto-generated, not part of create DTO usually
}

// DTO for updating a product
export interface ProductUpdateDto {
  name?: string;
  description?: string;
  price?: number;
  currency?: string;
  category?: ProductCategory | string;
  tags?: string[];
  stock?: number;
  images?: string[];
  isActive?: boolean;
  slug?: string; // Allow manual slug update if necessary, though usually auto-generated
}

// For client response (can be same as IProduct or a subset)
export type ProductResponseDto = IProduct; // For now, return the full product document

// Query parameters for listing products
export interface ProductListQueryOptions {
  limit?: number;
  page?: number;
  category?: string;
  tag?: string;
  isActive?: boolean;
  sortBy?: 'price' | 'createdAt' | 'name';
  sortOrder?: 'asc' | 'desc';
  search?: string; // For text search
}


class ProductService {
  public async create(data: ProductCreateDto): Promise<ProductResponseDto> {
    try {
      // Slug will be auto-generated by pre-save hook based on name
      const newProduct = new Product({
        ...data,
        currency: data.currency || 'USD', // Default currency if not provided
      });
      const savedProduct = await newProduct.save();
      return savedProduct;
    } catch (error: any) {
      if (error.code === 11000 && error.keyPattern && error.keyPattern.slug) {
        // This implies a slug collision, which might happen if names are very similar
        // or if a slug was manually set to an existing one.
        throw new AppError({ httpCode: HttpCode.CONFLICT, description: 'Product with this name (or resulting slug) already exists.' });
      }
      if (error.name === 'ValidationError') {
        const messages = Object.values(error.errors).map((err: any) => err.message).join(' ');
        throw new AppError({httpCode: HttpCode.BAD_REQUEST, description: messages});
      }
      console.error("Error creating product:", error);
      throw new AppError({ httpCode: HttpCode.INTERNAL_SERVER_ERROR, description: 'Failed to create product.' });
    }
  }

  public async findAll(queryOptions: ProductListQueryOptions = {}): Promise<{ products: ProductResponseDto[], total: number, page: number, pages: number }> {
    const {
        limit = 10,
        page = 1,
        category,
        tag,
        isActive,
        sortBy = 'createdAt',
        sortOrder = 'desc',
        search
    } = queryOptions;

    const query: mongoose.FilterQuery<IProduct> = {};

    if (category) {
      query.category = category;
    }
    if (tag) {
      query.tags = { \$in: [tag.toLowerCase()] };
    }
    if (isActive !== undefined) {
      query.isActive = isActive;
    }
    if (search) {
      // Basic case-insensitive search on name and description
      // For more advanced search, use text index: query.\$text = { \$search: search };
      query.\$or = [
        { name: { \$regex: search, \$options: 'i' } },
        { description: { \$regex: search, \$options: 'i' } },
        { tags: { \$regex: search, \$options: 'i' } } // Search in tags array
      ];
    }

    const sortCriteria: Record<string, mongoose.SortOrder> = {};
    sortCriteria[sortBy] = sortOrder === 'asc' ? 1 : -1;

    try {
      const total = await Product.countDocuments(query);
      const products = await Product.find(query)
        .sort(sortCriteria)
        .skip((page - 1) * limit)
        .limit(limit)
        .exec();

      return {
        products,
        total,
        page,
        pages: Math.ceil(total / limit),
      };
    } catch (error: any) {
      console.error("Error finding all products:", error);
      throw new AppError({ httpCode: HttpCode.INTERNAL_SERVER_ERROR, description: 'Failed to retrieve products.' });
    }
  }

  public async findById(id: string): Promise<ProductResponseDto | null> {
    if (!mongoose.Types.ObjectId.isValid(id)) {
      // throw new AppError({ httpCode: HttpCode.BAD_REQUEST, description: 'Invalid product ID format.' });
      return null; // Or throw, depending on desired behavior for controller
    }
    try {
      const product = await Product.findById(id);
      return product;
    } catch (error: any) {
      console.error(\`Error finding product by ID \${id}:\`, error);
      throw new AppError({ httpCode: HttpCode.INTERNAL_SERVER_ERROR, description: 'Failed to retrieve product.' });
    }
  }

  public async findBySlug(slug: string): Promise<ProductResponseDto | null> {
    try {
      const product = await Product.findOne({ slug: slug.toLowerCase() });
      return product;
    } catch (error: any) {
      console.error(\`Error finding product by slug \${slug}:\`, error);
      throw new AppError({ httpCode: HttpCode.INTERNAL_SERVER_ERROR, description: 'Failed to retrieve product.' });
    }
  }

  public async update(id: string, updateData: ProductUpdateDto): Promise<ProductResponseDto | null> {
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return null; // Or throw Bad Request
    }
    try {
      // If name is updated, slug should be regenerated by pre-save hook.
      // If slug is provided in updateData, it will attempt to set it directly.
      const product = await Product.findById(id);
      if (!product) return null;

      // Assign updates
      Object.keys(updateData).forEach(key => {
        // @ts-ignore - Assigning to IProduct attributes
        product[key] = updateData[key as keyof ProductUpdateDto];
      });

      const updatedProduct = await product.save(); // This will trigger pre-save hook for slug if name changed
      return updatedProduct;
    } catch (error: any) {
      if (error.code === 11000 && error.keyPattern && error.keyPattern.slug) {
        throw new AppError({ httpCode: HttpCode.CONFLICT, description: 'Product with this name (or resulting slug) already exists.' });
      }
      if (error.name === 'ValidationError') {
        const messages = Object.values(error.errors).map((err: any) => err.message).join(' ');
        throw new AppError({httpCode: HttpCode.BAD_REQUEST, description: messages});
      }
      console.error(\`Error updating product \${id}:\`, error);
      throw new AppError({ httpCode: HttpCode.INTERNAL_SERVER_ERROR, description: 'Failed to update product.' });
    }
  }

  public async delete(id: string): Promise<boolean> {
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return false; // Or throw Bad Request
    }
    try {
      // TODO: Consider soft delete (e.g., setting an `isDeleted` flag) instead of hard delete
      // For now, implementing hard delete.
      const result = await Product.deleteOne({ _id: id });
      return result.deletedCount === 1;
    } catch (error: any) {
      console.error(\`Error deleting product \${id}:\`, error);
      throw new AppError({ httpCode: HttpCode.INTERNAL_SERVER_ERROR, description: 'Failed to delete product.' });
    }
  }
}

export default new ProductService();
